"""Template for generating MCP server code."""

import os
from pathlib import Path
from jinja2 import Template


MCP_SERVER_TEMPLATE = """#!/usr/bin/env python3
\"\"\"
Auto-generated MCP server for ReadTheDocs documentation.
Generated by autodocs-mcp
\"\"\"

import asyncio
import sys
from pathlib import Path
from typing import Any, Sequence

from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import (
    Resource,
    Tool,
    TextContent,
    ImageContent,
    EmbeddedResource,
)
import chromadb
from sentence_transformers import SentenceTransformer

# Configuration
VECTOR_STORE_PATH = Path("{{ vector_store_path }}")
EMBEDDING_MODEL = "{{ embedding_model }}"
DOCUMENTATION_URL = "{{ documentation_url }}"

# Initialize components
client = chromadb.PersistentClient(path=str(VECTOR_STORE_PATH))
collection = client.get_or_create_collection(name="{{ collection_name }}")
embedding_model = SentenceTransformer(EMBEDDING_MODEL)

# Create MCP server
app = Server("readthedocs-docs")


@app.list_resources()
async def list_resources() -> list[Resource]:
    \"\"\"List available documentation resources.\"\"\"
        # Get all unique pages from collection
    try:
        results = collection.get(limit=10000)
    except Exception:
        results = {"metadatas": []}
    
    # Extract unique URLs
    urls = set()
    for metadata in results.get("metadatas", []):
        if metadata and "url" in metadata:
            urls.add(metadata["url"])
    
    resources = []
    for url in sorted(urls):
        resources.append(
            Resource(
                uri=f"docs://{url}",
                name=url.split("/")[-1] or "index",
                description=f"Documentation page: {url}",
                mimeType="text/markdown",
            )
        )
    
    return resources


@app.read_resource()
async def read_resource(uri: str) -> str:
    \"\"\"Read a documentation resource.\"\"\"
    if not uri.startswith("docs://"):
        raise ValueError(f"Invalid resource URI: {uri}")
    
    # Extract URL from URI
    url = uri.replace("docs://", "")
    
    # Search for content related to this URL
    try:
        results = collection.get(
            where={"url": url},
            limit=1000,
        )
    except Exception:
        results = {"documents": []}
    
    if not results.get("documents"):
        return f"# Documentation not found\\n\\nURL: {url}"
    
    # Combine all chunks for this page
    content_parts = []
    for doc in results["documents"]:
        content_parts.append(doc)
    
    return "\\n\\n---\\n\\n".join(content_parts)


@app.list_tools()
async def list_tools() -> list[Tool]:
    \"\"\"List available tools.\"\"\"
    return [
        Tool(
            name="search_documentation",
            description="Search the documentation using semantic search",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search query",
                    },
                    "max_results": {
                        "type": "integer",
                        "description": "Maximum number of results",
                        "default": 5,
                    },
                },
                "required": ["query"],
            },
        ),
        Tool(
            name="get_page_content",
            description="Get the full content of a specific documentation page",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL of the documentation page",
                    },
                },
                "required": ["url"],
            },
        ),
    ]


@app.call_tool()
async def call_tool(name: str, arguments: dict[str, Any] | None) -> Sequence[TextContent | ImageContent | EmbeddedResource]:
    \"\"\"Handle tool calls.\"\"\"
    if arguments is None:
        arguments = {}
    
    if name == "search_documentation":
        query = arguments.get("query", "")
        max_results = arguments.get("max_results", 5)
        
        if not query:
            return [TextContent(type="text", text="Error: Query is required")]
        
        # Generate query embedding
        try:
            query_embedding = embedding_model.encode([query])[0].tolist()
            
            # Search in vector store
            results = collection.query(
                query_embeddings=[query_embedding],
                n_results=max_results,
            )
        except Exception as e:
            return [TextContent(type="text", text=f"Error during search: {str(e)}")]
        
        if not results.get("ids") or len(results["ids"][0]) == 0:
            return [TextContent(type="text", text=f"No results found for: {query}")]
        
        # Format results
        output_parts = [f"# Search Results for: {query}\\n"]
        for i in range(len(results["ids"][0])):
            doc = results["documents"][0][i]
            metadata = results["metadatas"][0][i]
            distance = results["distances"][0][i] if "distances" in results else None
            
            output_parts.append(
                f"## Result {i+1}\\n"
                f"**Title:** {metadata.get('title', 'Unknown')}\\n"
                f"**URL:** {metadata.get('url', 'Unknown')}\\n"
                f"**Relevance:** {1 - distance if distance else 'N/A'}\\n"
                f"\\n**Content:**\\n{doc}\\n"
            )
        
        return [TextContent(type="text", text="\\n\\n---\\n\\n".join(output_parts))]
    
    elif name == "get_page_content":
        url = arguments.get("url", "")
        
        if not url:
            return [TextContent(type="text", text="Error: URL is required")]
        
        # Get all chunks for this URL
        try:
            results = collection.get(
                where={"url": url},
                limit=1000,  # Get all chunks
            )
        except Exception:
            results = {"documents": []}
        
        if not results.get("documents"):
            return [TextContent(type="text", text=f"Page not found: {url}")]
        
        # Combine chunks in order
        content_parts = []
        for doc in results["documents"]:
            content_parts.append(doc)
        
        full_content = "\\n\\n---\\n\\n".join(content_parts)
        
        return [TextContent(type="text", text=f"# {url}\\n\\n{full_content}")]
    
    else:
        return [TextContent(type="text", text=f"Unknown tool: {name}")]


async def main():
    \"\"\"Main entry point.\"\"\"
    async with stdio_server() as (read_stream, write_stream):
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options(),
        )


if __name__ == "__main__":
    asyncio.run(main())
"""


def generate_mcp_server(
    output_path: str,
    vector_store_path: str,
    embedding_model: str,
    documentation_url: str,
    collection_name: str = "documentation",
) -> str:
    """
    Generate MCP server code from template.
    
    Args:
        output_path: Path where to save the server file
        vector_store_path: Path to the vector store directory
        embedding_model: Name of the embedding model
        documentation_url: Original documentation URL
        collection_name: Name of the ChromaDB collection
        
    Returns:
        Path to the generated server file
    """
    template = Template(MCP_SERVER_TEMPLATE)
    
    # Convert paths to absolute
    vector_store_path = str(Path(vector_store_path).absolute())
    output_path = Path(output_path)
    
    # Render template
    code = template.render(
        vector_store_path=vector_store_path,
        embedding_model=embedding_model,
        documentation_url=documentation_url,
        collection_name=collection_name,
    )
    
    # Write to file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(code)
    
    # Make executable
    os.chmod(output_path, 0o755)
    
    return str(output_path)

